urlpatterns = [
    path('admin/', admin.site.urls),
    path('hello_world', views.HelloWorld.as_view()),
    # Paths for login
    path('login/register', views.Register.as_view())
]


Now that the structure is ready, let’s start building the actual logic. We will need username, password and email so let’s consider them as required parameters and store these keys to a list required_params. Our first step is to check if these are available and have valid values. To check the validity of required params we created a method validate_required_params which takes the param key, value and return value if it is valid else raises a ValidationError. We handled this exception to respond with a HTTP_400_BAD_REQUEST.


POST /login

This endpoint should basically take user credentials, validate them and return access and refresh tokens. Let’s start with creating an APIView with a post method. Credentials should always be passed in Authorization header of HTTP request, it should follow the Authorization: <type> <credentials> syntax. For this endpoint we will use Basic type which requires the credentials to be base64 encoded in <username>:<password> format.

To handle basic authentication requests, django rest framework has an inbuilt authentication class BasicAuthentication. This has to be added in the Login class along with the IsAuthenticated permission class. This makes the Login endpoint protected by basic authentication. At this point your Login class should look like this.

The logical next step is to generate token(s) for authenticated users. For this we will use Json Web Tokens (JWT) with the help of PyJWT. Basically, JWT is structured to have three parts separated by a dot(.). The first part is header which usually contain the type of the token and the hashing algorithm used. The second part is payload, where actual user claims are stored. The last part is the signature, which is basically a hash of header and payload generated using the algorithm specified in the header.

Our token payload should contain some recommended claims like issued time, issuer, audience, expiry etc. along with some user information. So, we will create a payload dictionary and sign the jwt with the SECRET_KEY which is generated by django in your app’s settings.py (to use this secret, you have to import settings from django.conf). We will also generate the refresh token in the same way but it will live longer than the access token. Finally send the response with these tokens and some other information.

Since we will use the entire token generation code in the refresh endpoint as well, we created a utils.py and created a generate_token method which takes User as argument and return access_token, refresh_token.


POST /login/refresh

This API is supposed to take refresh token and respond with a new set of access and refresh tokens if the refresh token is valid. We will create this endpoint similar to the login endpoint, but it will not need authentication.

For validating the refresh token, we will use PyJWT’s decode method. It will throw exceptions if the token is invalid for whatever reason. So, we need to handle these exceptions and respond back with an appropriate error message. After decoding we have to check the token’s type, if it is anything other than refresh, we will respond with a error. Then we will read the username from the token and use this to get the User object from the database. We pass this User object to generate_token method of utils to get access_token and refresh_token. If both of them are not none, we will respond back with tokens. 


This kind of token based approach is only secure if all the communications are made over HTTPS. It fails big time if used over HTTP. For real world use you can always rely on OAUTH2 for token based authentication, there are some good packages available for django for implementing OAUTH2.